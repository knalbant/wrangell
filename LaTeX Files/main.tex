\documentclass[preprint,nocopyrightspace]{sig-alternate}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{mathtools}

% standard packages that must be loaded after hyperref
\usepackage[auth-lg]{authblk}
\usepackage{bookmark}
\usepackage{booktabs}
\usepackage[final]{listings}
\usepackage{lscape}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage{flushend}
% local packages for just this paper
\usepackage{natbib-cite}
\usepackage{natbib-acm}
\usepackage{mathtools}
\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}


% packages that must be loaded after both hyperref and natbib
\usepackage{hypernat}
\usepackage{cleveref}

\usepackage{proof}
\crefname{section}{Section}{Sections}
\crefname{table}{Table}{Tables}
\crefname{figure}{Figure}{Figures}
\crefname{subfigure}{Figure}{Figures}



\begin{document}%

%\title{Wrangell: A Data-Wrangling DSL in Haskell}
\title{God Damn Monads: Dropping the Mic on Wrangell}

\author{Dana Iltis}
\author{Kenan Nalbant}
\author{Donald Pinckney}

\affil{\normalsize{University of California, Davis}\\
\{\texttt{driltis, kanalbant, djpinckney\}@ucdavis.edu}}

\maketitle

\begin{abstract}
Managing data from various document types (e.g. txt, csv files) often requires manual work by a user. We present Wrangell, a domain-specific language for common data manipulation tasks.

Run from the command line, Wrangell is specifically designed to modify tables of data wherein columns are separated by a user-specified delimiter. Wrangell has functions to read in a file, parse the data, run a transformation on the table, and write the modified table to an output file. 

We implemented Wrangell in Haskell, a functional programming language. We chose Haskell for its powerful type system which allows a large amount of control over how operations behave when handed various data types. Furthermore, as a functional programming language, Haskell is a good choice for tasks which depend on running transformations on data.

We based Wrangell on Scheme, a Lisp-like language known for its simplicity. Wrangell's simplicity is desirable as it would facilitate ease of integration into potential future data management projects.


\end{abstract}

\section{Introduction}
For our project, we wanted to design and implement a small language. Haskell was an attractive tool because of its type system in which data types are immutable and are defined algebraically. Furthermore, our team members had either a beginner or intermediate level of Haskell knowledge, so we saw this as an opportunity to learn something new. 

To keep the scope of our language's features manageable, we chose to gear our it to a specific domain. Because Haskell is a functional language, we thought that \emph{data-wrangling}, with its emphasis on data transformations, would be a good application for our language implemented in Haskell. We began creating Wrangell, a DSL for ``WRANGling'' data via ``haskELL''.  

We focused our desired data-wrangling tasks on one format: a table of data in a csv file, wherein we recognize rows via lines of the file, and columns per a user-specified delimiter. The following operations would initially be included in Wrangell:

\begin{enumerate}
\item Read in an input filename, output filename, () , ()
\item Read in and parse a csv file per a filename 
\item Run some transformation on the data in the file
\item Write the transformed data to an output file
\end{enumerate}

A motivating example for Wrangell could be the following: A small business has many csv files (say, one for each year the company has been active) with customer data. Each file has a column for various items including the customer's name, address, phone number, and credit card number. Now say the business wanted to contract some advertising company to mail a promotional catalog to each of its customers. In this case, the business would want to share its customer database with the advertising company. However, sharing customer credit card information with the advertising company would be both unnecessary and dangerous. In this case,  the business would want an easy way to make copies of the customer information files with the credit card information column removed.   


\section{Approach}

Because our team memebers only had beginner or intermediate levels of Haskell knowledge, we chose to keep Wrangell's data management operations fairly simple. 
As a result, Wranagell's application subjects are limited to tables of data wherein columns were separated by either a comma or a user-specified delimiter.

We determined big-step semantics for Wrangell's operations (Figure \ref{bigStep}).
Then we planned to apply Wrangell's data manipulation features to a variety of csv files with a data table formatted per the example in Figure \ref{exampleTable}.

We decided that Wrangell should support the following transformation operations:
\begin{enumerate}
\item Remove a column
\item Insert a column
\item Remove a row
\item Insert a row
\end{enumerate}

Blah blah blah. other stuff about the approach. 


\onecolumn
\begin{figure}
\caption{Big-step semantics for Wrangell's table manipulation functions}
\begin{enumerate}
\item Table$\\$
\begin{equation*}
\Sigma = \bigcup_{n=1,r=1}^{\infty}  \{M|t_i \epsilon T, m_{*i} \epsilon V(t_i:r),l_i \epsilon \{Strings\}, \forall l_i \nexists l_j s.t. \ l_i=l_j \wedge j\neq i\}
\end{equation*}
$\sigma[M] = (t_1,t_2,...,t_n),(m_{*1},m_{*2},...,m_{*n}), (l_1,l_2,...,l_n)$

\item Drop Column$\\$
\begin{equation*}
\infer{<dropCol \ name, \sigma> \Downarrow \\
\sigma ' 
}{<name,\sigma> \Downarrow l_i}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_{i-1},t_{i+1},...,t_n),(m_{*1},m_{*2},...,m_{*{i-1}},m_{*{i+1}},...,m_{*n}), (l_1,l_2,...,l_{i-1},l_{i+1},...,l_n)\}$

\item Drop Row$\\$\\
\begin{equation*}
\infer{<dropRow \ \lambda, \sigma> \Downarrow \\
\sigma ' 
}{m_{*i}'=\{m_{ji}|<\lambda m_{ji}, \sigma> \Downarrow False\}}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_n),(m_{*1}',m_{*2}',...,m_{*n}'), (l_1,l_2,...,l_n)\}$

\item Insert Column$\\$
\begin{equation*}
\infer{<insertCol  \ type \ name \ j , \sigma> \Downarrow \\
\sigma ' 
}{j \epsilon [1,n+1], \ name \ \epsilon \{l_1,l_2,...,l_n\}}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_{j-1},type,...,t_n),(m_{*1},m_{*2},...0()...,m_{*n}), (l_1,l_2,...,name,...,l_n)\}$
\end{enumerate}
\label{bigStep}
\end{figure}
\begin{figure}
\caption{Example of a Wrangell-compatible data table}
Filename: twinPeaksPeople.csv
\\\\
Name,   Age,Gender,	Favorite Food,	School,				Social Security Number \\
Dale,   40,	M,		Coffee,			Dartmouth			111111111\\
Audrey, 18,	F,		Coffee,			Twin Peaks High,	888888888\\
Laura,  17,	F,		Cereal,			Twin Peaks High,	000000000\\
Bobby,  17,	M,		Bacon,			Twin Peaks High,	333333333\\
Hawk,   34,	M,		Doughnuts,		Brandeis,			111223333\\
Ben,    48,	M,		Brie sandwich,	USC,				444556666\\
Hank,   34,	M,		Dominoes,		Prison GED Program,	888116666\\
Leo,    32,	M,		Raw Hamburger,	Sarah Lawrence,		000996666\\
Jacoby,  51, M,		Coconuts,		USC,				000997777\\
Blackie,	43, F,	Shirley Temple,	School of Lyfe,		999771111\\	
\label{exampleTable}	
\end{figure} 
\twocolumn


\section{Implementation and Results}
WE based Wrangell on Scheme.....
In coding Wrangell, most of our challenges centered on our need to mimic imperative behavior in Haskell, a functional language. We needed to store and modify table data, a goal which seems to contradict Haskell's `immutable data' requirement. Additionally, we needed to implement a type system which was flexible enough to represent lists for our table columns/rows. Finally, we needed to give Wrangell the ability to read and write csv files.  

\subsection{Modeling Wrangell After Scheme}
We based Wrangell on Scheme, a Lisp dialect. .....blah blah blah. For more on Scheme see 'Related Work' below. 


\subsection{Working with Haskell's Immutable Data}
In Haskell, data is immutable (see 'Immutable Data and Monads' in `Related Work'). Yet, we needed Wrangell to store and modify information about our original and transformed data tables. Our solution was to define tables using the \emph{data.IORef} package. With this package we constructed our \emph{Table} data type to be an \emph{IORef} of(WAIT WHAT "TODO this will be a bit different"). The code in Figure \ref{tableIORef} demonstrates our use of the IO monad during construction of an empty data table for later use (Later use example in Figure \ref{tableIoRefLaterUse}) . 
Without defining emptyTable as an IORef, we would have (encountered an error?) during later use. 

\begin{figure}
\caption{Creation of the `Table' data type within the IO Monad}
\begin{lstlisting}
-- datatypes.hs --
import Data.IORef
.
.
.
data Table' = 
Table' { rows :: [[WVal]], 
         format :: [WType], 
         labels :: [String], 
         delimiter :: String}
type Table = IORef Table' 
-- TODO: This will be a bit different
.
.
.
--creates a new empty table context
emptyTable :: IO Table
emptyTable = new IORef Table' {    
  rows   = [[]],
  format = [],
  labels = [],
  delimiter = ","
}
\end{lstlisting}
\label{tableIORef}
\end{figure}
Because emptyTable is in the IO monad, we can later () as follows:
\begin{figure}
\caption{placeholder}
\begin{lstlisting}
LATER USE OF THE TABLE CONTEXT/INSTANCE?
\end{lstlisting}
\label{tableIoRefLaterUse}
\end{figure}

\subsection{Type System Flexibility}
Wrangell needed a type system which was flexible enough to achieve our desired level of expressiveness, particularly when describing lists necessary to represent data table columns/rows. We initially defined type restrictions directly in 'funcTable' (Figure \ref{fig:inflexType}).
\begin{figure}
\caption{Inflexible type system: Type-checking occurs in funcTable, no type-checking in `'if' function definition}
\begin{lstlisting}
-- functions.hs --
.
.
.
funcTable :: [(FuncDef, [WVal] -> WVal)] 
functable = [
   (("if", [TBool, TFloat, TFloat]), if'),
   (("if", [TBool, TBool, TBool]), if'),
   (("car", [TList [TIntegral,TIntegral]]), 
      car' )]    
.
.
.          
if' :: [WVal] -> WVal
if' [condition, t, f] = 
    if unpackBool condition then t else f

\end{lstlisting}
\label{fig:inflexType}
\end{figure}
In this strategy we use funcTable to constrain exactly what inputs a function can accept. However, for the \emph{car} function (which computes the first item of a list), in order to describe lists of varying length and types, we would have to include a line (an instance of the funcTable? class?) for every possible combination of lengths and types!

Our solution (Figure \ref{fig:flexType}) was to move the type-checking of inputs into the functions themselves. This allows more flexibility in funcTable. However, because it would now be possible to pass incompatible data to a function, we needed a way for functions to handle potential errors. Our solution, described in related work, was to implement type-safe exception handling via the Either monad. 

Use the EITHER MONAD NOT THE MAYBE MONAD SO THAT WE CAN CARRY ERROR MESSAGES WITH US. 

\begin{figure}
\caption{Flexible type system: Type-checking now takes place in if' and car function definitions. No restrictions on types in funcTable' definitions.}
\begin{lstlisting}

-- functions.hs --
funcTable' :: 
   [(String, [WVal] -> ThrowsError WVal)]
FuncDef
functable = [  
    ("if", if')
    ("car", car)]
.
.
.
if' :: [WVal] -> ThrowsError WVal 
if' ifComps = do
  --error checking
  checkLength (==) 3 ifComps
  checkType TBool $ head ifComps

  --checks that the types 
  --  of the consequents match
  if getType t == getType f
  then return $ List $ tail ifComps
  else throwError $ TypeError 
       "expected types to match, 
        found" $ List $ tail ifComps

  --does the actual if computation
  if unpackBool cond 
     then return t 
     else return f

  where cond = head ifComps
        t    = ifComps !! 1
        f    = ifComps !! 2
.
.
.
car :: [WVal] -> ThrowsError WVal
car [List (x : _)] = return x
car [badArg]       = 
     throwError $ TypeError "pair" badArg
car badArgList     = 
     throwError $ NumArgs 1 badArgList

\end{lstlisting} 
\label{fig:flexType}
\end{figure}

\subsection{Reading and Writing csv Files}
For Wrangell's reading, parsing, and writing csv files, we used some existing code from the public GitHub repository MissingH \cite{dataCSV}. Specifically we used CSV.hs, which uses Data.csv to .....

More description of how Wrangell reads in files....  

\subsection{User-Generated Helper Functions}
in DataOperations.hs
Bellz n' Wisslez
IORef essential. 

\section{Related Work}

\subsection{Scheme}
Scheme is a Lisp dialect. It was useful to our construction of Wrangell because...

\subsection{Monads in Haskell}
As mentioned above, Wrangell needed to emulate imperative behavior in order to track and modify data. However in a functional language like Haskell, 

\subsection{Data.IORef and the IO Monad}
The IO Monad allows...
Essential in runRepl, which .... (Figure \ref{runReplIO})


\begin{figure}
\caption{IO monad used in runRepl, a function which ...()}
\label{runReplIO}
\begin{lstlisting}
-- main.hs --
runRepl :: IO ()
runRepl = do
  binds <- primitiveBindings
  table <- emptyTable
  doUntil_ (== "quit")
   (readPrompt "wrangell>>> ") 
   (evalAndPrint binds table)
\end{lstlisting}
\end{figure} 

\subsection{Type-Safe Exception Handling and the Either (Maybe?) Monad}
Wrangell's ThrowsError data type exists (?) within the Maybe (Either?) monad  \ref{eitherThrowsError}.
This is important becuase....
The either monad lets us string together the actions of..... in constructing the dropColumn operation. 
\begin{figure}
\caption{ThrowsError data type constructed within the Either monad. dropColumn uses ThrowsError to ()}
\label{eitherThrowsError}
\begin{lstlisting}
-- datatypes.hs -- 
type ThrowsError = Either WError

-- DataOperations.hs --
dropColumn :: 
  Env -> Table -> WVal 
  -> IOThrowsError WVal
dropColumn env table (Integral index) = 
  return Unit
dropColumn env table (String label) = 
  return Unit
dropColumn env table val =
 throwError $ TypeError 
  "Invalid type for dropColumn" val
\end{lstlisting}
\end{figure} 

\subsection{MissingH, Data.csv, CSV.hs}
MissingH is a publicly available repository of Haskell utility functions. We used CSV.hs to read/write csv files..... CSV.hs works like this: ... 



The IO monad (IORef)
 \emph{IO Monad}, an abstract data type which provides a system wherein we can build ``composite actions''. This allows us to mimic imperative behavior without requiring mutability of variables.  
Application to other file formats (hdf5)

data.csv



\section{Conclusions}
Wrangell 


Hypothetical future improvements to Wrangell might include improvement in label analysis, a feature which would allow users to identify columns purely via their label. For example, an operation meant to aggregate email addresses for all customers since 1995 would need to handle customer data files wherein the column "email address" is not present (e.g. files prior to 2002). Additionally, it would also be useful if Wrangell could handle files with inconsistent ordering of columns. Finally, we would want Wangell to be able to handle data tables with an unknown number of columns. 



\bibliography{main}
\end{document}
