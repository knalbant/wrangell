\documentclass[preprint,nocopyrightspace]{sig-alternate}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{mathtools}

% standard packages that must be loaded after hyperref
\usepackage[auth-lg]{authblk}
\usepackage{bookmark}
\usepackage{booktabs}
\usepackage[final]{listings}
\usepackage{lscape}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage{flushend}
% local packages for just this paper
\usepackage{natbib-cite}
\usepackage{natbib-acm}
\usepackage{mathtools}
\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}


% packages that must be loaded after both hyperref and natbib
\usepackage{hypernat}
\usepackage{cleveref}

\usepackage{proof}
\crefname{section}{Section}{Sections}
\crefname{table}{Table}{Tables}
\crefname{figure}{Figure}{Figures}
\crefname{subfigure}{Figure}{Figures}



\begin{document}%

%\title{Wrangell: A Data-Wrangling DSL in Haskell}
\title{God Damn Monads: Dropping the Mic on Wrangell}

\author{Dana Iltis}
\author{Kenan Nalbant}
\author{Donald Pinckney}

\affil{\normalsize{University of California, Davis}\\
\{\texttt{driltis, kanalbant, djpinckney\}@ucdavis.edu}}

\maketitle

\begin{abstract}
Managing data from various document types (e.g. txt, csv files) often requires manual work by a user. We present Wrangell, a domain-specific language for common data manipulation tasks.

Run from the command line, Wrangell is specifically designed to modify tables of data wherein columns are separated by a user-specified delimiter. Wrangell has functions to read in a file, parse the data, run a transformation on the table, and write the modified table to an output file. 

We implemented Wrangell in Haskell, a functional programming language. We chose Haskell for its powerful type system which allows a large amount of control over how operations behave when handed various data types. Furthermore, as a functional programming language, Haskell is a good choice for tasks which depend on running transformations on data.

We based Wrangell on Scheme, a Lisp-like language known for its simplicity. Wrangell's simplicity is desirable as it would facilitate ease of integration into potential future data management projects.


\end{abstract}

\section{Introduction}
For our project, we wanted to design and implement a small language. Haskell was an attractive tool because of its type system in which data types are immutable and are defined algebraically. Furthermore, our team members had either a beginner or intermediate level of Haskell knowledge, so we saw this as an opportunity to learn something new. 

To keep the scope of our language's features manageable, we chose to gear it to a specific domain. Because Haskell is a functional language, we thought that \emph{data-wrangling}, with its emphasis on data transformations, would be a good application for our language implemented in Haskell. Our resulting projectm, Wrangell, is a DSL for ``WRANGling'' data via ``haskELL''.  

We focused our desired data-wrangling tasks on one format: a table of data in a csv file, wherein we recognize rows via lines of the file, and columns per a user-specified delimiter. The following operations were to be supported by Wrangell:

\begin{enumerate}
\item Read in an input filename, output filename
\item Read in and parse a csv file per a filename 
\item Run some transformation on the data in the file
\item Write the transformed data to an output file
\end{enumerate}

A motivating example for Wrangell could be the following: A small business has many csv files (say, one for each year the company has been active) with customer data. Each file has a column for various items including the customer's name, address, phone number, and credit card number. Now say the business wanted to contract some advertising company to mail a promotional catalog to each of its customers. In this case, the business would want to share its customer database with the advertising company. However, sharing customer credit card information with the advertising company would be both unnecessary and dangerous. In this case,  the business would want an easy way to make copies of the customer information files with the credit card information column removed. Such a transformation should be supported by Wrangell.    


\section{Approach}

\subsection{Wrangell-Compatible Data}
Because our team members only had beginner or intermediate levels of Haskell knowledge, we chose to keep Wrangell's data management operations fairly simple. 
As a result, Wrangell's application subjects are limited to tables of data wherein columns are separated by either a comma or a user-specified delimiter. Furthermore, we allow the first row of data in a csv file to be a list of comma-separated labels, one for each column. We require that each column have a \emph{unique} label, to avoid ambiguity in potential future Wrangell features which may seek to identify columns per their labels. We decided to ultimately apply Wrangell to a variety of csv files. See Figure \ref{exampleTable} for an example of a Wrangell-compatible data table. 

\subsection{Semantics of Wrangell}
We decided that Wrangell should support the following transformation operations:
\begin{enumerate}
\item Remove a column
\item Insert a column
\item Remove a row
\item Insert a row
\end{enumerate}

We describe the big-step semantics for Wrangell's data transformation operations in Figure \ref{bigStep}.

\onecolumn

\begin{figure}
\caption{Example of a Wrangell-compatible data table}
Filename: twinPeaksPeople.csv
\\\\
Name,   Age,Gender,	Favorite Food,	School,				Social Security Number \\
Dale,   40,	M,		Coffee,			Dartmouth			111111111\\
Audrey, 18,	F,		Coffee,			Twin Peaks High,	888888888\\
Laura,  17,	F,		Cereal,			Twin Peaks High,	000000000\\
Bobby,  17,	M,		Bacon,			Twin Peaks High,	333333333\\
Hawk,   34,	M,		Doughnuts,		Brandeis,			111223333\\
Ben,    48,	M,		Brie sandwich,	USC,				444556666\\
Hank,   34,	M,		Dominoes,		Prison GED Program,	888116666\\
Leo,    32,	M,		Raw Hamburger,	Sarah Lawrence,		000996666\\
Jacoby,  51, M,		Coconuts,		USC,				000997777\\
Blackie,	43, F,	Shirley Temple,	School of Lyfe,		999771111\\	
\label{exampleTable}	
\end{figure} 

\begin{figure}
\caption{Big-step semantics for Wrangell's table manipulation functions}
\begin{enumerate}
\item Table$\\$
\begin{equation*}
\Sigma = \bigcup_{n=1,r=1}^{\infty}  \{M|t_i \epsilon T, m_{*i} \epsilon V(t_i:r),l_i \epsilon \{Strings\}, \forall l_i \nexists l_j s.t. \ l_i=l_j \wedge j\neq i\}
\end{equation*}
$\sigma[M] = (t_1,t_2,...,t_n),(m_{*1},m_{*2},...,m_{*n}), (l_1,l_2,...,l_n)$

\item Drop Column$\\$
\begin{equation*}
\infer{<dropCol \ name, \sigma> \Downarrow \\
\sigma ' 
}{<name,\sigma> \Downarrow l_i}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_{i-1},t_{i+1},...,t_n),(m_{*1},m_{*2},...,m_{*{i-1}},m_{*{i+1}},...,m_{*n}), (l_1,l_2,...,l_{i-1},l_{i+1},...,l_n)\}$

\item Drop Row$\\$\\
\begin{equation*}
\infer{<dropRow \ \lambda, \sigma> \Downarrow \\
\sigma ' 
}{m_{*i}'=\{m_{ji}|<\lambda m_{ji}, \sigma> \Downarrow False\}}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_n),(m_{*1}',m_{*2}',...,m_{*n}'), (l_1,l_2,...,l_n)\}$

\item Insert Column$\\$
\begin{equation*}
\infer{<insertCol  \ type \ name \ j , \sigma> \Downarrow \\
\sigma ' 
}{j \epsilon [1,n+1], \ name \ \epsilon \{l_1,l_2,...,l_n\}}
\end{equation*}
$\sigma ' [ M ] = \{(t_1,t_2,...,t_{j-1},type,...,t_n),(m_{*1},m_{*2},...0()...,m_{*n}), (l_1,l_2,...,name,...,l_n)\}$
\end{enumerate}
\label{bigStep}
\end{figure}

\twocolumn

\subsection{Monads in Haskell}
One of our biggest challenges in writing Wrangell would be simulating imperative behavior in Haskell.  
To carry out activities like storing and modifying table data, we would need to use various Haskell \emph{monads}, a `conceptual structure' \cite{gentleMonads} in Haskell which, for our purposes in Wrangell, would allow us to chain together multiple computations (e.g. a sequence of functions, or a passing of the result of one function to another).

In Wrangell, we planned to use the built-in \emph{Either} monad to manage errors such as the passing of the wrong data type to a function. For items in the Either monad, custom behavior can be defined for 2 cases: Left, wherein an error occurred, and Right, wherein the result was successfully parsed. We planned to use this to attach error descriptions for various data types.  

In Figure \ref{eitherThrowError0} , we define the data type `ThrowsError' to be in the Either monad, meaning any variable of type `ThrowsError' will also be within the Either monad. We then use the Either monad Right/Left functionality in the readOrThrow user input-parsing function to define the behaviors in the Left and Right cases (also in Figure \ref{eitherThrowError0}).

\begin{figure}
\begin{lstlisting}
-- datatypes.hs --

-- Define the ThrowsError to exist 
--   within the Either monad
type ThrowsError = Either WError
.
.
.

-- main.hs --

--Left signals error, Right a proper parse
readOrThrow :: 
  Parser a -> String -> ThrowsError a
readOrThrow parser input = 
  case parse parser "wrangell" input of
    Left err  -> throwError $ Parser err
    Right val -> return val 

\end{lstlisting}
\caption{Wrangell's use of the Either monad to define behavior in successful and unsuccessful cases in the readOrThrow function which parses user input}
\label{eitherThrowError0}
\end{figure}

\subsection{The IO Monad, Monad Transformers, and Lifting}
We planned to use the IO (`input/output') monad to handle user input to Wrangell. The IO monad would be useful in \emph{monad transformers} \cite{monadTransform}, wherein we would adapt data types in existing monads to also include input/output-related functionality. For this purpose, monad transformers would allow us to combine the behaviors of the IO monad with that of, say, error-handling monads into one data type. 

The IOThrowsError data type, for example, was inspired by an example we found in a Haskell tutorial \cite{writeScheme48}. Construction of the IOThrowsError data type in Figure \ref{IOThrowsError} uses the monad transformer \emph{ExceptT}. ExceptT incorporates the functionality of the Either monad and facilitates application of error handling to Wrangell errors (WError) in the IO monad. For example, Firuge \ref{IOThrowsError} also illustrates sample usage of IOThrowsError in the checkAllUnique function. checkAllUnique, which checks if the column labels provided to Wrangell are unique, uses ThrowError (which exists in the Either error-handling monad) \emph{and} .......()..... which exists in the IO monad. This is useful for.......()......

We also planned to use \emph{lifting} in Wrangell. For our purposes, lifting would be useful for............()..............

\begin{figure}
\begin{lstlisting}
-- datatypes.hs --

type IOThrowsError = ExceptT WError IO
.
.
.

-- DataOperations.hs --
checkAllUnique :: 
  [String] -> [WVal] -> IOThrowsError WVal
checkAllUnique labels wlabels = 
  if allUnique labels
    then return $ Unit 
    else throwError 
         $ FormatSpec 
           "Labels should be all unique: 
             " wlabels

\end{lstlisting}
\caption{IOThrowsError data type created via the ExceptT monad transformer. IOThrowsError later used in checkAllUnique which depends on functionality from both the Either and the IO monad.}
\label{IOThrowsError}
\end{figure}

  

\section{Implementation and Results}

In coding Wrangell, most of our challenges centered on our need to mimic imperative behavior in Haskell, a functional language. We needed to store and modify table data, a goal which seems to contradict Haskell's `immutable data' requirement. Additionally, we needed to implement a type system which was flexible enough to represent lists for our table columns/rows. Finally, we needed to give Wrangell the ability to read and write csv files.  

\subsection{Modeling Wrangell After Scheme}
We based Wrangell on Scheme, a Lisp dialect. .....blah blah blah. For more on Scheme see 'Related Work' below. 


\subsection{Working with Haskell's Immutable Data}
In Haskell, data is immutable (see 'Immutable Data and Monads' in `Related Work'). Yet, we needed Wrangell to store and modify information about our original and transformed data tables. Our solution was to define tables using the \emph{data.IORef} package. With this package we constructed our \emph{Table} data type to be an \emph{IORef} of(WAIT WHAT "TODO this will be a bit different"). The code in Figure \ref{tableIORef} demonstrates our use of the IO monad during construction of an empty data table for later use (Later use example in Figure \ref{tableIoRefLaterUse}) . 
Without defining emptyTable as an IORef, we would have (encountered an error?) during later use. 

\begin{figure}
\caption{Creation of the `Table' data type within the IO Monad}
\begin{lstlisting}
-- datatypes.hs --
import Data.IORef
.
.
.
data Table' = 
Table' { rows :: [[WVal]], 
         format :: [WType], 
         labels :: [String], 
         delimiter :: String}
type Table = IORef Table' 
-- TODO: This will be a bit different
.
.
.
--creates a new empty table context
emptyTable :: IO Table
emptyTable = new IORef Table' {    
  rows   = [[]],
  format = [],
  labels = [],
  delimiter = ","
}
\end{lstlisting}
\label{tableIORef}
\end{figure}
Because emptyTable is in the IO monad, we can later () as follows (Figure \ref{tableIoRefLaterUse}:
\begin{figure}
\caption{placeholder}
\begin{lstlisting}
LATER USE OF THE TABLE CONTEXT/INSTANCE?
\end{lstlisting}
\label{tableIoRefLaterUse}
\end{figure}

\subsection{Type System Flexibility}
Wrangell needed a type system which was flexible enough to achieve our desired level of expressiveness, particularly when describing lists necessary to represent data table columns/rows. We initially defined type restrictions directly in 'funcTable' (Figure \ref{fig:inflexType}).
\begin{figure}
\caption{Inflexible type system: Type-checking occurs in funcTable, no type-checking in `'if' function definition}
\begin{lstlisting}
-- functions.hs --
.
.
.
funcTable :: [(FuncDef, [WVal] -> WVal)] 
functable = [
   (("if", [TBool, TFloat, TFloat]), if'),
   (("if", [TBool, TBool, TBool]), if'),
   (("car", [TList [TIntegral,TIntegral]]), 
      car' )]    
.
.
.          
if' :: [WVal] -> WVal
if' [condition, t, f] = 
    if unpackBool condition then t else f

\end{lstlisting}
\label{fig:inflexType}
\end{figure}
In this strategy we use funcTable to constrain exactly what inputs a function can accept. However, for the \emph{car} function (which computes the first item of a list), in order to describe lists of varying length and types, we would have to include a line (an instance of the funcTable? class?) for every possible combination of lengths and types!

Our solution (Figure \ref{fig:flexType}) was to move the type-checking of inputs into the functions themselves. This allows more flexibility in funcTable. However, because it would now be possible to pass incompatible data to a function, we needed a way for functions to handle potential errors. Our solution, described in related work, was to implement type-safe exception handling via the Either monad. 

Use the EITHER MONAD NOT THE MAYBE MONAD SO THAT WE CAN CARRY ERROR MESSAGES WITH US. 

\begin{figure}
\caption{Flexible type system: Type-checking now takes place in if' and car function definitions. No restrictions on types in funcTable' definitions.}
\begin{lstlisting}

-- functions.hs --
funcTable' :: 
   [(String, [WVal] -> ThrowsError WVal)]
FuncDef
functable = [  
    ("if", if')
    ("car", car)]
.
.
.
if' :: [WVal] -> ThrowsError WVal 
if' ifComps = do
  --error checking
  checkLength (==) 3 ifComps
  checkType TBool $ head ifComps

  --checks that the types 
  --  of the consequents match
  if getType t == getType f
  then return $ List $ tail ifComps
  else throwError $ TypeError 
       "expected types to match, 
        found" $ List $ tail ifComps

  --does the actual if computation
  if unpackBool cond 
     then return t 
     else return f

  where cond = head ifComps
        t    = ifComps !! 1
        f    = ifComps !! 2
.
.
.
car :: [WVal] -> ThrowsError WVal
car [List (x : _)] = return x
car [badArg]       = 
     throwError $ TypeError "pair" badArg
car badArgList     = 
     throwError $ NumArgs 1 badArgList

\end{lstlisting} 
\label{fig:flexType}
\end{figure}

\subsection{Reading and Writing csv Files}
For Wrangell's reading, parsing, and writing csv files, we used  existing code from the public GitHub repository MissingH \cite{dataCSV}. Specifically we used CSV.hs, which uses Data.csv to parse comma-separated strings into lists of strings. 

To support potential extension of Wrangell we wrote code which converts input file formats to an intermediate Wrangell table. Additionally we wrote code to convert from the intermediate Wrangell table to an output file format. Because Wrangell's data transformations operate on the intermediate table, this allows Wrangell to be applicable to a variety of file formats. This means that, hypothetically, a future iteration of Wrangell could read in a csv file, and output, say, a txt file. 

More description of how Wrangell reads in files....  

\subsection{User-Generated Helper Functions}
in DataOperations.hs
Bellz n' Wisslez
IORef essential. 

\section{Related Work}

\subsection{Scheme}
Scheme is a Lisp dialect. It was useful to our construction of Wrangell because...
\cite{scheme}

\subsection{Monads in Haskell}
As mentioned above, Wrangell needed to emulate imperative behavior in order to track and modify data. However in a functional language like Haskell, 
Monad Transformers \citep{monadTransform}






\subsection{Data.IORef and the IO Monad}

\subsection{Type-Safe Exception Handling and the Either (Maybe?) Monad}
Wrangell's ThrowsError data type exists (?) within the Maybe (Either?) monad  \ref{eitherThrowsError}.
This is important becuase....
The either monad lets us string together the actions of..... in constructing the dropColumn operation. 
\begin{figure}
\caption{ThrowsError data type constructed within the Either monad. dropColumn uses ThrowsError to ()}
\label{eitherThrowsError}
\begin{lstlisting}
-- datatypes.hs -- 
type ThrowsError = Either WError

-- DataOperations.hs --
dropColumn :: 
  Env -> Table -> WVal 
  -> IOThrowsError WVal
dropColumn env table (Integral index) = 
  return Unit
dropColumn env table (String label) = 
  return Unit
dropColumn env table val =
 throwError $ TypeError 
  "Invalid type for dropColumn" val
\end{lstlisting}
\end{figure} 

\subsection{MissingH, Data.csv, CSV.hs}
MissingH is a publicly available repository of Haskell utility functions. We used CSV.hs to read/write csv files..... CSV.hs works like this: ... 


The IO monad (IORef)
 \emph{IO Monad}, an abstract data type which provides a system wherein we can build ``composite actions''. This allows us to mimic imperative behavior without requiring mutability of variables.  
Application to other file formats (hdf5)

data.csv

\subsection{DSLs}
\cite{DSLs}
As a Domain Specific Language, Wrangell was intended to be a fast, simple tool to carry out data management tasks. Paul Hudak's paper on Domain Specific Languages champions the usefulness of program written in DSL's because of these exact qualities \cite{DSLs}. An idea not yet addressed in our discussion of Wrangell is Hudak's point that DSL's are more usable by those without significant programming expertise. For industries where users are less likely to have programming experience (e.g. finance), tools like Wrangell are highly desirable. 

\section{Conclusions}
Wrangell succesfully....().... 

Future improvements to Wrangell might include improvement in label analysis, a feature which would allow users to identify columns purely via their label. For example, an operation meant to aggregate email addresses for all customers since 1995 would need to handle customer data files wherein the column "email address" is not present (e.g. files prior to 2002). It would also be useful if Wrangell could handle files with inconsistent ordering of columns. Additionally, we would want Wrangell to be able to handle data tables with an unknown number of columns. 

As mentioned in our discussion of Wrangell's capabilities for reading and writing csv files, Wrangell might also be extended to read in and output more file formats.   


\bibliography{main}
\end{document}
